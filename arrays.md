---
title: Multidimensional arrays
---

Common Lisp has native support for multidimensional arrays, with some
special treatment for 1-D arrays, called `vectors`. Arrays can be
*generalised* and contain any type (`element-type t`), or they
can be *specialised* to contain specific types such as `single-float`
or `integer`. A good place to start is 
[Practical Common Lisp Chapter 11, Collections](http://www.gigamonkeys.com/book/collections.html) by
Peter Seibel.

Some libraries available on Quicklisp for manipulating arrays:

- [array-operations](https://github.com/tpapp/array-operations)defines
  functions `generate`, `permute`, `displace`, `flatten`, `split`,
  `combine`, `reshape`. It also defines `each`, for element-wise
  operations. 
- [cmu-infix](https://github.com/rigetticomputing/cmu-infix) includes
  array indexing syntax for multidimensional arrays.

This page covers what can be done with the built-in multidimensional
arrays, but there are limitations. In particular:

* Interoperabiltiy with foreign language arrays, for example when
  calling libraries such as BLAS, LAPACK or GSL. 
* Extending arithmetic and other mathematical operators to handle
  arrays, for example so that `(+ a b)` works 
  when `a` and/or `b` are arrays. 

Both of these problems can be solved by using CLOS to define an
extended array class, with native arrays as a special case. 
Some libraries available through `quicklisp` which take this approach
are: 

* [MGL-MAT](https://github.com/melisgl/mgl-mat), which has a manual
  and provides bindings to BLAS and CUDA. This is used in a machine
  learning library [MGL](https://github.com/melisgl/mgl).
* [cl-ana](https://github.com/ghollisjr/cl-ana/wiki), a data analysis
  package with a manual, which includes operations on arrays.
* [matlisp](https://github.com/matlisp/matlisp)
* [Antik](https://www.common-lisp.net/project/antik/)

Taking this approach further, full DSLs have been built on Common
Lisp, which can be used for numerical calculations with arrays.
At the time of writing the most widely used and supported of these are:

* [Maxima](http://maxima.sourceforge.net/documentation.html)
* [Axiom](https://github.com/daly/axiom)


# Creating

The function [CHLS: make-array](http://clhs.lisp.se/Body/f_mk_ar.htm)
can create arrays filled with a single value

~~~lisp
* (defparameter *my-array* (make-array '(3 2) :initial-element 1.0))
*MY-ARRAY*
* *my-array*
#2A((1.0 1.0) (1.0 1.0) (1.0 1.0))
~~~

More complicated array values can be generated by first making an
array, and then iterating over the elements to fill in the values (see
section below on element access). The `array-operations` library
provides `generate`, a convenient function for creating arrays which
wraps this iteration.

~~~lisp
* (ql:quickload :array-operations)
To load "array-operations":
  Load 1 ASDF system:
    array-operations
; Loading "array-operations"

(:ARRAY-OPERATIONS)

* (aops:generate #'identity 7 :position)
#(0 1 2 3 4 5 6)
~~~

Note that the nickname for `array-operations` is `aops`. 

To create an 3x3 array containing random numbers drawn from a uniform
distribution, `generate` can be used to call the built-in `random` function:

~~~lisp
* (aops:generate (lambda () (random 1.0)) '(3 3))
#2A((0.99292254 0.929777 0.93538976)
    (0.31522608 0.45167792 0.9411855)
    (0.96221936 0.9143338 0.21972346))
~~~

# Accessing elements

To access the individual elements of an array there are the `aref`,
`elt` and `row-major-aref` functions. 


The [cmu-infix](https://github.com/rigetticomputing/cmu-infix) library
provides some different syntax which can make mathematical expressions
easier to read:

~~~lisp
* (ql:quickload :cmu-infix)
To load "cmu-infix":
  Load 1 ASDF system:
    cmu-infix
; Loading "cmu-infix"

(:CMU-INFIX)

* (named-readtables:in-readtable cmu-infix:syntax)
(("COMMON-LISP-USER" . #<NAMED-READTABLE CMU-INFIX:SYNTAX {10030158B3}>)
 ...)
 
* (defparameter arr (make-array '(3 2) :initial-element 1.0))
ARR

* #i(arr[0 1] = 2.0)
2.0

* arr
#2A((1.0 2.0) (1.0 1.0) (1.0 1.0))
~~~

A matrix-matrix multiply operation can be implemented as:
~~~lisp
(let ((A #2A((1 2) (3 4)))
      (B #2A((5 6) (7 8)))
      (result (make-array '(2 2) :initial-element 0.0)))
     
     (loop for i from 0 to 1 do 
           (loop for j from 0 to 1 do
                 (loop for k from 0 to 1 do
                       #i(result[i j] += A[i k] * B[k j]))))
      result)
~~~

# Element-wise operations



Foreign arrays
--------------

